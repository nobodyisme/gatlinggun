#!/usr/bin/env python
from ConfigParser import ConfigParser
import copy
import logging
from multiprocessing import Process
import os.path
import sys
import time

import msgpack
from opster import command
import tornado
from tornado import web

import elliptics
from gatlinggun.config import JsonConfig
from gatlinggun import daemon
from gatlinggun.errors import ConnectionError, InvalidDataError, EmptyQueue
from gatlinggun.gun import Gun
from gatlinggun import helpers as h
from gatlinggun.logger import logger, setup_logger
from gatlinggun.mastermind_client import ReconnectableService
from gatlinggun import monitor
from gatlinggun import sync
from gatlinggun.transport import ZkTransport as Transport


DEFAULT_LOGGING_CONFIG_PATH = '/etc/elliptics/gatlinggun/logging-default.conf'
LOGGING_CONFIG_PATH = '/etc/elliptics/gatlinggun/logging.conf'

DEFAULT_PIDFILE = '/var/run/elliptics-gatlinggun/gatlinggun'


@command(usage='-c CONFIG -l LOGGING_CONFIG'
               '[--daemonize] [--pidfile PIDFILE] [--user USER]')
def main(config=('c', '', 'Application config file'),
         log_config=('l', '', 'Application logging config file'),
         daemonize=('', False, 'Daemonize this process'),
         pidfile=('', None, 'Use this pidfile'),
         user=('', None, '')):
    """This script starts gatling gun daemon that
    distributes keys to designated cache nodes"""

    main_config = ConfigParser()

    if not config:
        raise RuntimeError('Application config is required (-c|--config)')

    if not main_config.read(config):
        raise RuntimeError('Failed to open config file: {0}'.format(config))

    use_log_config = DEFAULT_LOGGING_CONFIG_PATH
    if log_config:
        use_log_config = log_config
    elif os.path.exists(LOGGING_CONFIG_PATH):
        use_log_config = LOGGING_CONFIG_PATH

    if daemonize:
        user = user or main_config.get('global', 'user')
        d = daemon.Daemon(pidfile or DEFAULT_PIDFILE, user)
        d.run = run
        d.start(main_config, use_log_config)
    else:
        run(main_config, use_log_config)


def run(config, log_config):
    logging_config = JsonConfig(log_config)
    setup_logger(logging_config['logging'])

    if config.has_option('global', 'monitor_port'):
        p = Process(target=monitor_app, args=(config,))
        p.start()

    node = h.make_elliptics_node(config)

    gun = Gun(node, config.get('elliptics', 'cache_path_prefix'))
    zk_addresses = config.get('zookeeper', 'addresses')
    logger.info('Connection to transport hosts %s' % zk_addresses)
    if isinstance(zk_addresses, unicode):
        zk_addresses = zk_addresses.encode('utf-8')
    transport = Transport(gun.local_cache_groups,
        config.get('zookeeper', 'task_path'),
        host=zk_addresses, timeout=3)

    sync.PeriodThread(gun.update_local_cache_groups,
                      config.getint('global', 'sync_keys_period')
                      if config.has_option('global', 'sync_keys_period') else
                      10
    ).start()

    mastermind = ReconnectableService(config.get('mastermind', 'app'),
        config.get('mastermind', 'addresses'))
    # synchronizer = sync.Synchronizer(node, group, transport, service)
    # pth = sync.PeriodThread(synchronizer.sync_keys,
    #                         config.getint('global', 'sync_keys_period')).start()

    logger.info('Starting task processing')

    while True:
        logger.info('Fetching task from queue')

        try:
            with transport.item() as item:
                if not item:
                    raise EmptyQueue('No item fetched')
                task = msgpack.unpackb(item)

                logger.info('Task %s fetched' % task['key'])
                logger.debug('Task %s: %s' % (task['key'], task))
                gun.process(task)
                logger.info('Task %s processed' % (task['key'],))

        except ConnectionError as e:
            logger.exception(e)

        except InvalidDataError as e:
            logger.error(e)

        except EmptyQueue:
            pass

        except Exception as e:
            logger.exception(e)
            # the last key was unlocked, we are sleeping for that matter cause
            # we are hoping that some other daemon will fetch it and do better
        finally:
            time.sleep(1)


def monitor_app(config):
    mon = monitor.Monitor(config)
    application = web.Application([
        (r"/stats/", monitor.MonitorHandler, {'monitor': mon})
    ], gzip=True)
    application.listen(config.get('global', 'monitor_port'))
    tornado.ioloop.IOLoop.instance().start()


if __name__ == '__main__':
    main.command()
